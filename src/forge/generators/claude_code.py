"""
Claude Code CLI backend for code generation

Implements code generation using Claude Code CLI with workspace management.
"""

import subprocess
import asyncio
import time
import shutil
from pathlib import Path
from typing import Dict, Optional

from forge.generators.base import (
    CodeGenerator,
    GenerationContext,
    GenerationResult,
    GeneratorError
)
from forge.utils.logger import logger


class ClaudeCodeGenerator(CodeGenerator):
    """
    Code generator using Claude Code CLI.

    Features:
    - Workspace management
    - Specification file generation
    - Result collection
    - Sequential execution only (no parallel)
    """

    def __init__(
        self,
        workspace_dir: Optional[Path] = None,
        claude_binary: str = "claude"
    ):
        """
        Initialize Claude Code generator.

        Args:
            workspace_dir: Directory for workspace files (defaults to .forge/workspaces)
            claude_binary: Path to claude binary
        """
        self.workspace_dir = workspace_dir or Path(".forge/workspaces")
        self.claude_binary = claude_binary

        # Ensure workspace directory exists
        self.workspace_dir.mkdir(parents=True, exist_ok=True)

        # Check if claude is available
        if not shutil.which(claude_binary):
            logger.warning(f"Claude binary '{claude_binary}' not found in PATH")

        logger.info(f"Initialized Claude Code generator (workspace={self.workspace_dir})")

    async def generate(self, context: GenerationContext) -> GenerationResult:
        """
        Generate code using Claude Code CLI.

        Args:
            context: Generation context

        Returns:
            GenerationResult with generated files

        Raises:
            GeneratorError: If generation fails
        """
        self.validate_context(context)

        start_time = time.time()

        try:
            # Create workspace for this task
            workspace = self._create_workspace(context)

            # Generate specification file
            spec_file = self._create_specification(workspace, context)

            # Run Claude Code CLI
            logger.info(f"Running Claude Code for task {context.task_id}")

            result = await self._run_claude(workspace, spec_file)

            # Collect generated files
            files = self._collect_files(workspace)

            duration = time.time() - start_time

            if not files:
                raise GeneratorError("No files generated by Claude Code")

            return GenerationResult(
                success=result.returncode == 0,
                files=files,
                duration_seconds=duration,
                error=result.stderr if result.returncode != 0 else None,
                metadata={
                    "task_id": context.task_id,
                    "workspace": str(workspace),
                    "backend": "claude_code"
                }
            )

        except Exception as e:
            duration = time.time() - start_time
            error_msg = f"Claude Code generation failed: {e}"
            logger.error(error_msg)

            return GenerationResult(
                success=False,
                error=error_msg,
                duration_seconds=duration,
                metadata={"task_id": context.task_id}
            )

    def _create_workspace(self, context: GenerationContext) -> Path:
        """
        Create workspace directory for task.

        Args:
            context: Generation context

        Returns:
            Path to workspace directory
        """
        workspace = self.workspace_dir / context.task_id
        workspace.mkdir(parents=True, exist_ok=True)

        logger.debug(f"Created workspace: {workspace}")
        return workspace

    def _create_specification(self, workspace: Path, context: GenerationContext) -> Path:
        """
        Create specification file for Claude Code.

        Args:
            workspace: Workspace directory
            context: Generation context

        Returns:
            Path to specification file
        """
        spec_file = workspace / "SPEC.md"

        spec_content = []

        # Title
        spec_content.append(f"# Task: {context.task_id}")
        spec_content.append("")

        # Project context
        spec_content.append("## Project Context")
        spec_content.append(context.project_context)
        spec_content.append("")

        # Tech stack
        if context.tech_stack:
            spec_content.append("## Technology Stack")
            for tech in context.tech_stack:
                spec_content.append(f"- {tech}")
            spec_content.append("")

        # Dependencies
        if context.dependencies:
            spec_content.append("## Dependencies")
            spec_content.append("This task depends on:")
            for dep in context.dependencies:
                spec_content.append(f"- {dep}")
            spec_content.append("")

        # KnowledgeForge patterns
        if context.knowledgeforge_patterns:
            spec_content.append("## KnowledgeForge Patterns to Apply")
            for pattern in context.knowledgeforge_patterns:
                spec_content.append(f"- {pattern}")
            spec_content.append("")

        # Specification
        spec_content.append("## Specification")
        spec_content.append(context.specification)
        spec_content.append("")

        # Write to file
        spec_file.write_text("\n".join(spec_content))

        logger.debug(f"Created specification: {spec_file}")
        return spec_file

    async def _run_claude(self, workspace: Path, spec_file: Path) -> subprocess.CompletedProcess:
        """
        Run Claude Code CLI.

        Args:
            workspace: Workspace directory
            spec_file: Specification file

        Returns:
            CompletedProcess result
        """
        cmd = [
            self.claude_binary,
            "code",
            "--workspace", str(workspace),
            "--spec", str(spec_file)
        ]

        logger.debug(f"Running command: {' '.join(cmd)}")

        # Run asynchronously
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(workspace)
        )

        stdout, stderr = await process.communicate()

        return subprocess.CompletedProcess(
            args=cmd,
            returncode=process.returncode,
            stdout=stdout.decode(),
            stderr=stderr.decode()
        )

    def _collect_files(self, workspace: Path) -> Dict[str, str]:
        """
        Collect generated files from workspace.

        Args:
            workspace: Workspace directory

        Returns:
            Dictionary mapping file paths to content
        """
        files = {}

        # Collect all non-spec files
        for filepath in workspace.rglob("*"):
            if filepath.is_file() and filepath.name != "SPEC.md":
                # Get relative path from workspace
                rel_path = filepath.relative_to(workspace)

                # Read content
                try:
                    content = filepath.read_text()
                    files[str(rel_path)] = content
                except Exception as e:
                    logger.warning(f"Failed to read {filepath}: {e}")

        logger.debug(f"Collected {len(files)} files from workspace")
        return files

    async def health_check(self) -> bool:
        """
        Check if Claude Code CLI is available.

        Returns:
            True if CLI is available
        """
        try:
            result = await asyncio.create_subprocess_exec(
                self.claude_binary,
                "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            await result.communicate()
            return result.returncode == 0

        except Exception as e:
            logger.warning(f"Claude Code health check failed: {e}")
            return False

    def estimate_duration(self, context: GenerationContext) -> int:
        """
        Estimate generation duration.

        Claude Code typically takes longer than API calls.

        Args:
            context: Generation context

        Returns:
            Estimated duration in seconds
        """
        base_time = 60  # Base 1 minute

        # Add time based on specification complexity
        spec_time = len(context.specification) // 500 * 30  # 30s per 500 chars

        # Add time for dependencies
        dep_time = len(context.dependencies) * 20  # 20s per dependency

        total = base_time + spec_time + dep_time

        return min(total, 600)  # Cap at 10 minutes

    def supports_parallel(self) -> bool:
        """Claude Code runs sequentially"""
        return False

    def max_context_tokens(self) -> int:
        """Maximum context window size"""
        return 200000  # Claude's extended context

    def cleanup_workspace(self, task_id: str):
        """
        Clean up workspace for a task.

        Args:
            task_id: Task ID to clean up
        """
        workspace = self.workspace_dir / task_id

        if workspace.exists():
            import shutil
            shutil.rmtree(workspace)
            logger.debug(f"Cleaned up workspace: {workspace}")
