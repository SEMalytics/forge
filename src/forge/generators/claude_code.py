"""
Claude Code CLI backend for code generation

Implements code generation using Claude Code CLI with workspace management.
Supports streaming output for real-time progress feedback.
"""

import subprocess
import asyncio
import time
import shutil
from pathlib import Path
from typing import Dict, Optional, TYPE_CHECKING

from forge.generators.base import (
    CodeGenerator,
    GenerationContext,
    GenerationResult,
    GeneratorError
)
from forge.utils.logger import logger

if TYPE_CHECKING:
    from forge.core.streaming import StreamEmitter


class ClaudeCodeGenerator(CodeGenerator):
    """
    Code generator using Claude Code CLI.

    Features:
    - Workspace management
    - Specification file generation
    - Result collection
    - Sequential execution only (no parallel)
    """

    def __init__(
        self,
        workspace_dir: Optional[Path] = None,
        claude_binary: str = "claude"
    ):
        """
        Initialize Claude Code generator.

        Args:
            workspace_dir: Directory for workspace files (defaults to .forge/workspaces)
            claude_binary: Path to claude binary
        """
        self.workspace_dir = workspace_dir or Path(".forge/workspaces")
        self.claude_binary = claude_binary

        # Ensure workspace directory exists
        self.workspace_dir.mkdir(parents=True, exist_ok=True)

        # Check if claude is available
        if not shutil.which(claude_binary):
            logger.warning(f"Claude binary '{claude_binary}' not found in PATH")

        logger.info(f"Initialized Claude Code generator (workspace={self.workspace_dir})")

    async def generate(self, context: GenerationContext) -> GenerationResult:
        """
        Generate code using Claude Code CLI.

        Args:
            context: Generation context

        Returns:
            GenerationResult with generated files

        Raises:
            GeneratorError: If generation fails
        """
        self.validate_context(context)

        start_time = time.time()

        try:
            # Create workspace for this task
            workspace = self._create_workspace(context)

            # Generate specification file
            spec_file = self._create_specification(workspace, context)

            # Run Claude Code CLI
            logger.info(f"Running Claude Code for task {context.task_id}")

            result = await self._run_claude(workspace, spec_file)

            # Collect generated files
            files = self._collect_files(workspace)

            duration = time.time() - start_time

            if not files:
                raise GeneratorError("No files generated by Claude Code")

            return GenerationResult(
                success=result.returncode == 0,
                files=files,
                duration_seconds=duration,
                error=result.stderr if result.returncode != 0 else None,
                metadata={
                    "task_id": context.task_id,
                    "workspace": str(workspace),
                    "backend": "claude_code"
                }
            )

        except Exception as e:
            duration = time.time() - start_time
            error_msg = f"Claude Code generation failed: {e}"
            logger.error(error_msg)

            return GenerationResult(
                success=False,
                error=error_msg,
                duration_seconds=duration,
                metadata={"task_id": context.task_id}
            )

    async def generate_streaming(
        self,
        context: GenerationContext,
        emitter: 'StreamEmitter'
    ) -> GenerationResult:
        """
        Generate code with streaming progress and output.

        Provides real-time feedback during Claude Code CLI execution.

        Args:
            context: Generation context
            emitter: StreamEmitter for progress events

        Returns:
            GenerationResult with generated files
        """
        self.validate_context(context)

        start_time = time.time()

        try:
            await emitter.started(f"Starting Claude Code generation for {context.task_id}")

            # Check for cancellation
            if emitter.is_cancelled:
                await emitter.cancelled()
                return GenerationResult(
                    success=False,
                    error="Cancelled",
                    duration_seconds=time.time() - start_time
                )

            # Create workspace
            await emitter.stage("workspace", "Creating workspace...")
            await emitter.progress(0.1)
            workspace = self._create_workspace(context)

            # Generate specification
            await emitter.stage("specification", "Generating specification file...")
            await emitter.progress(0.2)
            spec_file = self._create_specification(workspace, context)

            if emitter.is_cancelled:
                await emitter.cancelled()
                return GenerationResult(
                    success=False,
                    error="Cancelled",
                    duration_seconds=time.time() - start_time
                )

            # Run Claude Code with streaming output
            await emitter.stage("generation", "Running Claude Code...")
            await emitter.progress(0.25)

            result = await self._run_claude_streaming(workspace, spec_file, emitter)

            if emitter.is_cancelled:
                await emitter.cancelled()
                return GenerationResult(
                    success=False,
                    error="Cancelled",
                    duration_seconds=time.time() - start_time
                )

            # Collect files
            await emitter.stage("collection", "Collecting generated files...")
            await emitter.progress(0.9)

            files = self._collect_files(workspace)

            # Emit file events
            for filepath, content in files.items():
                await emitter.file_completed(filepath, len(content))

            duration = time.time() - start_time

            generation_result = GenerationResult(
                success=result.returncode == 0 and len(files) > 0,
                files=files,
                duration_seconds=duration,
                error=result.stderr if result.returncode != 0 else None,
                metadata={
                    "task_id": context.task_id,
                    "workspace": str(workspace),
                    "backend": "claude_code"
                }
            )

            if generation_result.success:
                await emitter.completed(
                    f"Generated {len(files)} files",
                    metadata={"files": list(files.keys()), "duration": duration}
                )
            else:
                await emitter.failed(result.stderr or "No files generated")

            return generation_result

        except Exception as e:
            duration = time.time() - start_time
            error_msg = f"Claude Code generation failed: {e}"
            await emitter.failed(error_msg)

            return GenerationResult(
                success=False,
                error=error_msg,
                duration_seconds=duration,
                metadata={"task_id": context.task_id}
            )

    async def _run_claude_streaming(
        self,
        workspace: Path,
        spec_file: Path,
        emitter: 'StreamEmitter'
    ) -> subprocess.CompletedProcess:
        """
        Run Claude Code CLI with streaming output.

        Args:
            workspace: Workspace directory
            spec_file: Specification file
            emitter: StreamEmitter for output streaming

        Returns:
            CompletedProcess result
        """
        cmd = [
            self.claude_binary,
            "code",
            "--workspace", str(workspace),
            "--spec", str(spec_file)
        ]

        logger.debug(f"Running command: {' '.join(cmd)}")

        # Run with streaming stdout/stderr
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(workspace)
        )

        stdout_buffer = []
        stderr_buffer = []
        progress = [0.25]  # Start from 25%

        async def read_stream(stream, buffer, is_stderr=False):
            """Read from stream and emit chunks"""
            while True:
                if emitter.is_cancelled:
                    process.terminate()
                    break

                line = await stream.readline()
                if not line:
                    break

                decoded = line.decode()
                buffer.append(decoded)

                # Emit chunk
                if not is_stderr:
                    await emitter.chunk(decoded)

                    # Update progress gradually
                    if progress[0] < 0.85:
                        progress[0] = min(progress[0] + 0.02, 0.85)
                        await emitter.progress(progress[0])
                else:
                    # Log stderr as warnings
                    await emitter.warning(decoded.strip())

        # Read both streams concurrently
        await asyncio.gather(
            read_stream(process.stdout, stdout_buffer),
            read_stream(process.stderr, stderr_buffer, is_stderr=True)
        )

        await process.wait()

        return subprocess.CompletedProcess(
            args=cmd,
            returncode=process.returncode,
            stdout="".join(stdout_buffer),
            stderr="".join(stderr_buffer)
        )

    def supports_streaming(self) -> bool:
        """Claude Code supports streaming output"""
        return True

    def _create_workspace(self, context: GenerationContext) -> Path:
        """
        Create workspace directory for task.

        Args:
            context: Generation context

        Returns:
            Path to workspace directory
        """
        workspace = self.workspace_dir / context.task_id
        workspace.mkdir(parents=True, exist_ok=True)

        logger.debug(f"Created workspace: {workspace}")
        return workspace

    def _create_specification(self, workspace: Path, context: GenerationContext) -> Path:
        """
        Create specification file for Claude Code.

        Args:
            workspace: Workspace directory
            context: Generation context

        Returns:
            Path to specification file
        """
        spec_file = workspace / "SPEC.md"

        spec_content = []

        # Title
        spec_content.append(f"# Task: {context.task_id}")
        spec_content.append("")

        # Project context
        spec_content.append("## Project Context")
        spec_content.append(context.project_context)
        spec_content.append("")

        # Tech stack
        if context.tech_stack:
            spec_content.append("## Technology Stack")
            for tech in context.tech_stack:
                spec_content.append(f"- {tech}")
            spec_content.append("")

        # Dependencies
        if context.dependencies:
            spec_content.append("## Dependencies")
            spec_content.append("This task depends on:")
            for dep in context.dependencies:
                spec_content.append(f"- {dep}")
            spec_content.append("")

        # KnowledgeForge patterns
        if context.knowledgeforge_patterns:
            spec_content.append("## KnowledgeForge Patterns to Apply")
            for pattern in context.knowledgeforge_patterns:
                spec_content.append(f"- {pattern}")
            spec_content.append("")

        # Specification
        spec_content.append("## Specification")
        spec_content.append(context.specification)
        spec_content.append("")

        # Write to file
        spec_file.write_text("\n".join(spec_content))

        logger.debug(f"Created specification: {spec_file}")
        return spec_file

    async def _run_claude(self, workspace: Path, spec_file: Path) -> subprocess.CompletedProcess:
        """
        Run Claude Code CLI.

        Args:
            workspace: Workspace directory
            spec_file: Specification file

        Returns:
            CompletedProcess result
        """
        cmd = [
            self.claude_binary,
            "code",
            "--workspace", str(workspace),
            "--spec", str(spec_file)
        ]

        logger.debug(f"Running command: {' '.join(cmd)}")

        # Run asynchronously
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            cwd=str(workspace)
        )

        stdout, stderr = await process.communicate()

        return subprocess.CompletedProcess(
            args=cmd,
            returncode=process.returncode,
            stdout=stdout.decode(),
            stderr=stderr.decode()
        )

    def _collect_files(self, workspace: Path) -> Dict[str, str]:
        """
        Collect generated files from workspace.

        Args:
            workspace: Workspace directory

        Returns:
            Dictionary mapping file paths to content
        """
        files = {}

        # Collect all non-spec files
        for filepath in workspace.rglob("*"):
            if filepath.is_file() and filepath.name != "SPEC.md":
                # Get relative path from workspace
                rel_path = filepath.relative_to(workspace)

                # Read content
                try:
                    content = filepath.read_text()
                    files[str(rel_path)] = content
                except Exception as e:
                    logger.warning(f"Failed to read {filepath}: {e}")

        logger.debug(f"Collected {len(files)} files from workspace")
        return files

    async def health_check(self) -> bool:
        """
        Check if Claude Code CLI is available.

        Returns:
            True if CLI is available
        """
        try:
            result = await asyncio.create_subprocess_exec(
                self.claude_binary,
                "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            await result.communicate()
            return result.returncode == 0

        except Exception as e:
            logger.warning(f"Claude Code health check failed: {e}")
            return False

    def estimate_duration(self, context: GenerationContext) -> int:
        """
        Estimate generation duration.

        Claude Code typically takes longer than API calls.

        Args:
            context: Generation context

        Returns:
            Estimated duration in seconds
        """
        base_time = 60  # Base 1 minute

        # Add time based on specification complexity
        spec_time = len(context.specification) // 500 * 30  # 30s per 500 chars

        # Add time for dependencies
        dep_time = len(context.dependencies) * 20  # 20s per dependency

        total = base_time + spec_time + dep_time

        return min(total, 600)  # Cap at 10 minutes

    def supports_parallel(self) -> bool:
        """Claude Code runs sequentially"""
        return False

    def max_context_tokens(self) -> int:
        """Maximum context window size"""
        return 200000  # Claude's extended context

    def cleanup_workspace(self, task_id: str):
        """
        Clean up workspace for a task.

        Args:
            task_id: Task ID to clean up
        """
        workspace = self.workspace_dir / task_id

        if workspace.exists():
            import shutil
            shutil.rmtree(workspace)
            logger.debug(f"Cleaned up workspace: {workspace}")
